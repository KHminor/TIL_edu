# 재귀로 푸는 선택 정렬 함수 만들기 -- p1
# def sel_sort(s,e):
#     if s == e:
#         return
#     else:
#         m = s
#         for i in range(s+1,n):
#             if a[i] < a[m]:
#                 m = i
#         a[s],a[m] = a[m],a[s]
#         sel_sort(s+1,e)
#
# n = 5
# a = [3,2,4,1,6]
# print(a)
# sel_sort(0,n-1)
# print(a)


# 고지식한 방법(brute-force)
# 문제를 해결하기 위한 간단하고 쉬운 접근법으로 just do it 그냥 해보자 이런 느낌?
# 그래서 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 다소 느릴 수 있지만,
# 해답을 찾아내지 못할 확률은 작다.
# 그래서 이런 브루트포스의 완전 탐색 or 검색을 기반으로 그리디 기법이나, 동적 계획법을 이용해서
# 효율적인 알고리즘을 찾을 수 있다.

# 그리디(Greedy)알고리즘
# 당장 눈 앞에 보이는 최적의 상황만을 쫒는 알고리즘으로 가장 단순한 형태의 알고리즘으로
# 항상 최적의 결과를 도출하는 것은 아니지만 어느 정도 최적의 해에
# 근사한 값을 빠르게 구할 수 있다는 장점이 있다.

# DP(Dynamic Programming)
# 하나의 문제는 단 한 번만 풀도록 하는 알고리즘으로
# 한 번 푼 것을 여러 번 다시 푸는 비효율적인 알고리즘을 개선시키는 방법
# DP는 다음이 가정 하에 사용할 수 있다고 한다.
# 1. 큰 문제를 작은 문제로 나눌 수 있다
# 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
# 즉 크고 어려운 문제가 있으면 그것을 먼저 잘게 나누어서 해결한 뒤에 처리하여
# 나중에 전체의 답을 구하는 것.
# 다만 이 과정에서 메모이제이션이 사용된다는 점에 분할 정복과 다르다.
# 이유로는 이미 계산한 결과는 배열에 저장함으로써 나중에 동일한 계산을 해야 할 때는
# 저장된 값을 단순히 반환하기만 하면 되기 때문이다.



